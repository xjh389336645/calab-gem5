# 实验四 使用gem5探索指令级并行
## 实验目的
1.	体验优化代码增加指令级并行性，加深对指令级并行的理解
2.	了解有序处理器的ILP限制
3.	通过实际优化代码和分析数据，加深对性能分析的理解和认识

## 实验要求
1.	本次实验我们会继续使用gem5，有所区别的是，为了完成本次实验，我们会使用arm指令集架构而不是X86。我们使用 ARM（ISA）的主要原因是因为 ARM提供了一个高性能有序处理器的实现。使用 ARM 会增加编译代码的额外复杂性。我们必须交叉编译应用程序，而不是仅仅运行 gcc 或任何其他常用的编译器。
使用命令” python3 `which scons` build/ARM/gem5.opt ”来编译ARM版的gem5. (内存大于8G的可以考虑加上-j4/-j8等)。
2.	阅读并理解提供的daxpy，需要注意的是该程序会一个接一个地运行所有六个函数，并在每个函数之间使用 m5_dump_reset_stats() 来分离统计不同函数的性能表现。因此，在运行程序时，你将有八个不同的统计转储。(体现在stat.ini中)
3.	请使用提供的Makefile， daxpy.cc，安装好的交叉编译器和命令”make”编译程序daxpy。如果需要可以修改Makefile中编译器的路径，但请在实验没有明确要求时不要修改编译选项。
4.	使用命令“build/ARM/gem5.opt configs/example/arm/starter_se.py daxpy --cpu=hpi”运行样例程序，验证编译的正确性。
这将使用“HPI”（ high-performance in-order）核心运行应用程序。你可以在 configs/common/cores/arm/HPI.py 中找到 HPI 核心的配置。你可以查看一下代码的具体内容，在后续的实验中你需要对该文件进行一些修改。
5.	对于代码中的三个函数，重写三个函数的循环展开版本减少hazard。对于你修改后的循环展开版本函数，自己证明你所做的修改不影响函数的执行结果，即对于相同输入，改写后的函数仍能得到相同的结果。
6.	完成函数改写后请重新编译程序并使用gem5仿真执行，记录运行每一个函数所得的以下数据：CPI，执行时长，指令条数。(注意指令条数请参考committedInsts统计项，而不要参考sim_insts统计项)。
7.	修改HPI.py文件(路径：configs/common/cores/arm/HPI.py)来为仿真处理器增加SIMD/浮点处理单元，这将允许处理器并行执行更多的浮点操作，降低CPI。(修改内容: 修改class HPI_FUPool ,在它的funcUnits的最后增加额外的三个HPI_FloatSimdFU()。) 修改后重新使用gem5仿真执行daxpy.
8.	修改 Makefile 以对 GCC 使用 -O3 选项而不是 -O1。这告诉编译器使用最高级别的优化。
9.	实验需要提交的内容包括:
    a)	三次模拟运行daxpy的统计输出文件
    b)	改写后的daxpy文件
    c)	实验报告，内容需要包括：
    1. 如何证明展开循环后的函数产生了正确的结果？
    2. 对于每一个函数，循环展开是否提升了性能？循环展开减少了哪一种hazard？
    3. 你应该展开循环多少次？每个循环都一样吗？如果你没有展开足够多或展开太多会影响程序性能吗？
    4. 增加硬件对循环展开版本的函数和原函数有什么影响？添加更多硬件会减少哪种或哪些hazard？
    5. 选择你认为合适的指标比较四个版本函数的性能表现，为什么选择该指标？
    6. 你认为本次实验中你所进行的手动循环展开优化有意义吗？还是说编译器优化代码就已经足够了？说明理由。

## 注意：

1.	在进行实验第六步时，请注意查看正确的统计信息。 stats.txt 文件将包含多段dump信息，因此你需要确保正在查看正确的函数执行对应的仿真信息。
2.	在完成第8步后，你应当对每一种函数都有了四个版本：(1)原函数;(2)手动循环展开函数;(3)GCC-优化后的原函数;(4)GCC-优化后的手动循环展开函数

## 评分标准
1.	完成实验的基本要求，即提交的实验统计数据满足要求，提交的daxpy文件的循环展开正确，能获得5分。
2.	实验报告占5分


## 实验附件
1.	本次实验会提供需要使用的交叉编译器(gcc-linaro-6.4.1-2017.11-x86_64_aarch64-linux-gnu.tar), 为了能够使用交叉编译器，你需要把提供的文件解压到ubuntu机器上，然后把bin文件夹添加到系统路径。
2.	实验提供了一个简单的程序代码daxpy，其中包含三个不同的函数：daxpy(double a*x+y); daxsbxpxy( double a*x^2+b*x+x*y)和一个含有跨循环相关的简单数组运算。每个函数有两种实现：一个是简单的 for 循环的原始版本，以及一个“展开”版本。你需要使用高指令集并行的实现填充”展开”的版本。

